"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/[locale]/(app)/vacancies/page",{

/***/ "(app-pages-browser)/./lib/api.ts":
/*!********************!*\
  !*** ./lib/api.ts ***!
  \********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ApiError: function() { return /* binding */ ApiError; },\n/* harmony export */   apiFetch: function() { return /* binding */ apiFetch; },\n/* harmony export */   apiUpload: function() { return /* binding */ apiUpload; },\n/* harmony export */   getPreferredLocale: function() { return /* binding */ getPreferredLocale; }\n/* harmony export */ });\n/* harmony import */ var _lib_auth_store__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/lib/auth-store */ \"(app-pages-browser)/./lib/auth-store.ts\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n\nvar _process_env_NEXT_PUBLIC_API_URL;\nconst API_URL = (_process_env_NEXT_PUBLIC_API_URL = process.env.NEXT_PUBLIC_API_URL) !== null && _process_env_NEXT_PUBLIC_API_URL !== void 0 ? _process_env_NEXT_PUBLIC_API_URL : \"/api\";\nconst LOCALE_STORAGE_KEY = \"locale\";\nfunction getPreferredLocale() {\n    if (false) {}\n    const stored = localStorage.getItem(LOCALE_STORAGE_KEY);\n    if (stored) {\n        return stored;\n    }\n    const cookieMatch = document.cookie.match(/(?:^|; )NEXT_LOCALE=([^;]+)/);\n    return cookieMatch ? decodeURIComponent(cookieMatch[1]) : null;\n}\nclass ApiError extends Error {\n    constructor(message, status, code, details){\n        super(message);\n        this.status = status;\n        this.code = code;\n        this.details = details;\n    }\n}\nasync function refreshToken() {\n    const refreshToken = _lib_auth_store__WEBPACK_IMPORTED_MODULE_0__.useAuthStore.getState().refreshToken;\n    if (!refreshToken) {\n        return null;\n    }\n    const preferredLocale = getPreferredLocale();\n    const response = await fetch(\"\".concat(API_URL, \"/auth/refresh\"), {\n        method: \"POST\",\n        headers: {\n            \"Content-Type\": \"application/json\",\n            ...preferredLocale ? {\n                \"Accept-Language\": preferredLocale\n            } : {}\n        },\n        body: JSON.stringify({\n            refresh_token: refreshToken\n        })\n    });\n    if (!response.ok) {\n        _lib_auth_store__WEBPACK_IMPORTED_MODULE_0__.useAuthStore.getState().clearTokens();\n        return null;\n    }\n    const data = await response.json();\n    _lib_auth_store__WEBPACK_IMPORTED_MODULE_0__.useAuthStore.getState().setTokens(data.access_token, data.refresh_token);\n    return data.access_token;\n}\nasync function apiFetch(path) {\n    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    const accessToken = _lib_auth_store__WEBPACK_IMPORTED_MODULE_0__.useAuthStore.getState().accessToken;\n    var _options_headers;\n    const headers = new Headers((_options_headers = options.headers) !== null && _options_headers !== void 0 ? _options_headers : {});\n    if (!(options.body instanceof FormData)) {\n        headers.set(\"Content-Type\", \"application/json\");\n    }\n    const preferredLocale = getPreferredLocale();\n    if (preferredLocale) {\n        headers.set(\"Accept-Language\", preferredLocale);\n    }\n    if (accessToken) {\n        headers.set(\"Authorization\", \"Bearer \".concat(accessToken));\n    }\n    const response = await fetch(\"\".concat(API_URL).concat(path), {\n        ...options,\n        headers\n    });\n    if (response.status === 401) {\n        const newToken = await refreshToken();\n        if (newToken) {\n            var _options_headers1;\n            const retryHeaders = new Headers((_options_headers1 = options.headers) !== null && _options_headers1 !== void 0 ? _options_headers1 : {});\n            if (!(options.body instanceof FormData)) {\n                retryHeaders.set(\"Content-Type\", \"application/json\");\n            }\n            if (preferredLocale) {\n                retryHeaders.set(\"Accept-Language\", preferredLocale);\n            }\n            retryHeaders.set(\"Authorization\", \"Bearer \".concat(newToken));\n            const retry = await fetch(\"\".concat(API_URL).concat(path), {\n                ...options,\n                headers: retryHeaders\n            });\n            if (!retry.ok) {\n                throw new ApiError(await retry.text(), retry.status);\n            }\n            return await retry.json();\n        }\n    }\n    if (!response.ok) {\n        var _response_headers_get;\n        const contentType = (_response_headers_get = response.headers.get(\"content-type\")) !== null && _response_headers_get !== void 0 ? _response_headers_get : \"\";\n        if (contentType.includes(\"application/json\")) {\n            const data = await response.json();\n            var _data_message;\n            throw new ApiError((_data_message = data.message) !== null && _data_message !== void 0 ? _data_message : \"Request failed\", response.status, data.code, data.details);\n        }\n        const message = await response.text();\n        throw new ApiError(message || \"Request failed\", response.status);\n    }\n    if (response.status === 204) {\n        return {};\n    }\n    return await response.json();\n}\nasync function apiUpload(path, formData, onProgress) {\n    let didRetry = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;\n    const accessToken = _lib_auth_store__WEBPACK_IMPORTED_MODULE_0__.useAuthStore.getState().accessToken;\n    const preferredLocale = getPreferredLocale();\n    const uploadWithToken = (token)=>new Promise((resolve, reject)=>{\n            const xhr = new XMLHttpRequest();\n            xhr.open(\"POST\", \"\".concat(API_URL).concat(path));\n            if (token) {\n                xhr.setRequestHeader(\"Authorization\", \"Bearer \".concat(token));\n            }\n            if (preferredLocale) {\n                xhr.setRequestHeader(\"Accept-Language\", preferredLocale);\n            }\n            if (xhr.upload && onProgress) {\n                xhr.upload.onprogress = (event)=>{\n                    if (event.lengthComputable) {\n                        onProgress(Math.round(event.loaded / event.total * 100));\n                    }\n                };\n            }\n            xhr.onload = ()=>{\n                if (xhr.status === 401 && !didRetry) {\n                    refreshToken().then((newToken)=>{\n                        if (newToken) {\n                            return apiUpload(path, formData, onProgress, true).then(resolve).catch(reject);\n                        }\n                        reject(new ApiError(\"Unauthorized\", 401, \"UNAUTHORIZED\"));\n                        return null;\n                    }).catch(reject);\n                    return;\n                }\n                if (xhr.status >= 400) {\n                    try {\n                        const data = JSON.parse(xhr.responseText);\n                        var _data_message;\n                        reject(new ApiError((_data_message = data.message) !== null && _data_message !== void 0 ? _data_message : \"Request failed\", xhr.status, data.code, data.details));\n                    } catch (error) {\n                        reject(new ApiError(xhr.responseText || \"Request failed\", xhr.status));\n                    }\n                    return;\n                }\n                if (!xhr.responseText) {\n                    resolve({});\n                    return;\n                }\n                resolve(JSON.parse(xhr.responseText));\n            };\n            xhr.onerror = ()=>{\n                reject(new ApiError(\"Network error\", xhr.status || 0));\n            };\n            xhr.send(formData);\n        });\n    return uploadWithToken(accessToken);\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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SztvQkFDckIsSUFBSTt3QkFDRixNQUFNZ0IsT0FBT0wsS0FBSytDLEtBQUssQ0FBQ2YsSUFBSWdCLFlBQVk7NEJBQ3BCM0M7d0JBQXBCMEIsT0FBTyxJQUFJOUMsU0FBU29CLENBQUFBLGdCQUFBQSxLQUFLakIsT0FBTyxjQUFaaUIsMkJBQUFBLGdCQUFnQixrQkFBa0IyQixJQUFJM0MsTUFBTSxFQUFFZ0IsS0FBS2YsSUFBSSxFQUFFZSxLQUFLZCxPQUFPO29CQUMzRixFQUFFLE9BQU8wRCxPQUFPO3dCQUNkbEIsT0FBTyxJQUFJOUMsU0FBUytDLElBQUlnQixZQUFZLElBQUksa0JBQWtCaEIsSUFBSTNDLE1BQU07b0JBQ3RFO29CQUNBO2dCQUNGO2dCQUNBLElBQUksQ0FBQzJDLElBQUlnQixZQUFZLEVBQUU7b0JBQ3JCbEIsUUFBUSxDQUFDO29CQUNUO2dCQUNGO2dCQUNBQSxRQUFROUIsS0FBSytDLEtBQUssQ0FBQ2YsSUFBSWdCLFlBQVk7WUFDckM7WUFDQWhCLElBQUlrQixPQUFPLEdBQUc7Z0JBQ1puQixPQUFPLElBQUk5QyxTQUFTLGlCQUFpQitDLElBQUkzQyxNQUFNLElBQUk7WUFDckQ7WUFDQTJDLElBQUltQixJQUFJLENBQUMzQjtRQUNYO0lBRUYsT0FBT0csZ0JBQWdCZjtBQUN6QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9saWIvYXBpLnRzPzY4YTEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlQXV0aFN0b3JlIH0gZnJvbSBcIkAvbGliL2F1dGgtc3RvcmVcIjtcblxuY29uc3QgQVBJX1VSTCA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0FQSV9VUkwgPz8gXCIvYXBpXCI7XG5jb25zdCBMT0NBTEVfU1RPUkFHRV9LRVkgPSBcImxvY2FsZVwiO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UHJlZmVycmVkTG9jYWxlKCkge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IHN0b3JlZCA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKExPQ0FMRV9TVE9SQUdFX0tFWSk7XG4gIGlmIChzdG9yZWQpIHtcbiAgICByZXR1cm4gc3RvcmVkO1xuICB9XG4gIGNvbnN0IGNvb2tpZU1hdGNoID0gZG9jdW1lbnQuY29va2llLm1hdGNoKC8oPzpefDsgKU5FWFRfTE9DQUxFPShbXjtdKykvKTtcbiAgcmV0dXJuIGNvb2tpZU1hdGNoID8gZGVjb2RlVVJJQ29tcG9uZW50KGNvb2tpZU1hdGNoWzFdKSA6IG51bGw7XG59XG5cbmV4cG9ydCBjbGFzcyBBcGlFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgc3RhdHVzOiBudW1iZXI7XG4gIGNvZGU/OiBzdHJpbmc7XG4gIGRldGFpbHM/OiB1bmtub3duO1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlOiBzdHJpbmcsIHN0YXR1czogbnVtYmVyLCBjb2RlPzogc3RyaW5nLCBkZXRhaWxzPzogdW5rbm93bikge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzO1xuICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgdGhpcy5kZXRhaWxzID0gZGV0YWlscztcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiByZWZyZXNoVG9rZW4oKSB7XG4gIGNvbnN0IHJlZnJlc2hUb2tlbiA9IHVzZUF1dGhTdG9yZS5nZXRTdGF0ZSgpLnJlZnJlc2hUb2tlbjtcbiAgaWYgKCFyZWZyZXNoVG9rZW4pIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBwcmVmZXJyZWRMb2NhbGUgPSBnZXRQcmVmZXJyZWRMb2NhbGUoKTtcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfVVJMfS9hdXRoL3JlZnJlc2hgLCB7XG4gICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICBoZWFkZXJzOiB7XG4gICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgIC4uLihwcmVmZXJyZWRMb2NhbGUgPyB7IFwiQWNjZXB0LUxhbmd1YWdlXCI6IHByZWZlcnJlZExvY2FsZSB9IDoge30pLFxuICAgIH0sXG4gICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyByZWZyZXNoX3Rva2VuOiByZWZyZXNoVG9rZW4gfSksXG4gIH0pO1xuICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgdXNlQXV0aFN0b3JlLmdldFN0YXRlKCkuY2xlYXJUb2tlbnMoKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICB1c2VBdXRoU3RvcmUuZ2V0U3RhdGUoKS5zZXRUb2tlbnMoZGF0YS5hY2Nlc3NfdG9rZW4sIGRhdGEucmVmcmVzaF90b2tlbik7XG4gIHJldHVybiBkYXRhLmFjY2Vzc190b2tlbiBhcyBzdHJpbmc7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhcGlGZXRjaDxUPihcbiAgcGF0aDogc3RyaW5nLFxuICBvcHRpb25zOiBSZXF1ZXN0SW5pdCA9IHt9XG4pOiBQcm9taXNlPFQ+IHtcbiAgY29uc3QgYWNjZXNzVG9rZW4gPSB1c2VBdXRoU3RvcmUuZ2V0U3RhdGUoKS5hY2Nlc3NUb2tlbjtcbiAgY29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKG9wdGlvbnMuaGVhZGVycyA/PyB7fSk7XG4gIGlmICghKG9wdGlvbnMuYm9keSBpbnN0YW5jZW9mIEZvcm1EYXRhKSkge1xuICAgIGhlYWRlcnMuc2V0KFwiQ29udGVudC1UeXBlXCIsIFwiYXBwbGljYXRpb24vanNvblwiKTtcbiAgfVxuICBjb25zdCBwcmVmZXJyZWRMb2NhbGUgPSBnZXRQcmVmZXJyZWRMb2NhbGUoKTtcbiAgaWYgKHByZWZlcnJlZExvY2FsZSkge1xuICAgIGhlYWRlcnMuc2V0KFwiQWNjZXB0LUxhbmd1YWdlXCIsIHByZWZlcnJlZExvY2FsZSk7XG4gIH1cbiAgaWYgKGFjY2Vzc1Rva2VuKSB7XG4gICAgaGVhZGVycy5zZXQoXCJBdXRob3JpemF0aW9uXCIsIGBCZWFyZXIgJHthY2Nlc3NUb2tlbn1gKTtcbiAgfVxuXG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QVBJX1VSTH0ke3BhdGh9YCwge1xuICAgIC4uLm9wdGlvbnMsXG4gICAgaGVhZGVycyxcbiAgfSk7XG5cbiAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDAxKSB7XG4gICAgY29uc3QgbmV3VG9rZW4gPSBhd2FpdCByZWZyZXNoVG9rZW4oKTtcbiAgICBpZiAobmV3VG9rZW4pIHtcbiAgICAgIGNvbnN0IHJldHJ5SGVhZGVycyA9IG5ldyBIZWFkZXJzKG9wdGlvbnMuaGVhZGVycyA/PyB7fSk7XG4gICAgICBpZiAoIShvcHRpb25zLmJvZHkgaW5zdGFuY2VvZiBGb3JtRGF0YSkpIHtcbiAgICAgICAgcmV0cnlIZWFkZXJzLnNldChcIkNvbnRlbnQtVHlwZVwiLCBcImFwcGxpY2F0aW9uL2pzb25cIik7XG4gICAgICB9XG4gICAgICBpZiAocHJlZmVycmVkTG9jYWxlKSB7XG4gICAgICAgIHJldHJ5SGVhZGVycy5zZXQoXCJBY2NlcHQtTGFuZ3VhZ2VcIiwgcHJlZmVycmVkTG9jYWxlKTtcbiAgICAgIH1cbiAgICAgIHJldHJ5SGVhZGVycy5zZXQoXCJBdXRob3JpemF0aW9uXCIsIGBCZWFyZXIgJHtuZXdUb2tlbn1gKTtcbiAgICAgIGNvbnN0IHJldHJ5ID0gYXdhaXQgZmV0Y2goYCR7QVBJX1VSTH0ke3BhdGh9YCwge1xuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICBoZWFkZXJzOiByZXRyeUhlYWRlcnMsXG4gICAgICB9KTtcbiAgICAgIGlmICghcmV0cnkub2spIHtcbiAgICAgICAgdGhyb3cgbmV3IEFwaUVycm9yKGF3YWl0IHJldHJ5LnRleHQoKSwgcmV0cnkuc3RhdHVzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoYXdhaXQgcmV0cnkuanNvbigpKSBhcyBUO1xuICAgIH1cbiAgfVxuXG4gIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICBjb25zdCBjb250ZW50VHlwZSA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwiY29udGVudC10eXBlXCIpID8/IFwiXCI7XG4gICAgaWYgKGNvbnRlbnRUeXBlLmluY2x1ZGVzKFwiYXBwbGljYXRpb24vanNvblwiKSkge1xuICAgICAgY29uc3QgZGF0YSA9IChhd2FpdCByZXNwb25zZS5qc29uKCkpIGFzIHsgbWVzc2FnZT86IHN0cmluZzsgY29kZT86IHN0cmluZzsgZGV0YWlscz86IHVua25vd24gfTtcbiAgICAgIHRocm93IG5ldyBBcGlFcnJvcihkYXRhLm1lc3NhZ2UgPz8gXCJSZXF1ZXN0IGZhaWxlZFwiLCByZXNwb25zZS5zdGF0dXMsIGRhdGEuY29kZSwgZGF0YS5kZXRhaWxzKTtcbiAgICB9XG4gICAgY29uc3QgbWVzc2FnZSA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICB0aHJvdyBuZXcgQXBpRXJyb3IobWVzc2FnZSB8fCBcIlJlcXVlc3QgZmFpbGVkXCIsIHJlc3BvbnNlLnN0YXR1cyk7XG4gIH1cbiAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gMjA0KSB7XG4gICAgcmV0dXJuIHt9IGFzIFQ7XG4gIH1cbiAgcmV0dXJuIChhd2FpdCByZXNwb25zZS5qc29uKCkpIGFzIFQ7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhcGlVcGxvYWQ8VD4oXG4gIHBhdGg6IHN0cmluZyxcbiAgZm9ybURhdGE6IEZvcm1EYXRhLFxuICBvblByb2dyZXNzPzogKHByb2dyZXNzOiBudW1iZXIpID0+IHZvaWQsXG4gIGRpZFJldHJ5ID0gZmFsc2Vcbik6IFByb21pc2U8VD4ge1xuICBjb25zdCBhY2Nlc3NUb2tlbiA9IHVzZUF1dGhTdG9yZS5nZXRTdGF0ZSgpLmFjY2Vzc1Rva2VuO1xuICBjb25zdCBwcmVmZXJyZWRMb2NhbGUgPSBnZXRQcmVmZXJyZWRMb2NhbGUoKTtcblxuICBjb25zdCB1cGxvYWRXaXRoVG9rZW4gPSAodG9rZW46IHN0cmluZyB8IG51bGwpOiBQcm9taXNlPFQ+ID0+XG4gICAgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICB4aHIub3BlbihcIlBPU1RcIiwgYCR7QVBJX1VSTH0ke3BhdGh9YCk7XG4gICAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoXCJBdXRob3JpemF0aW9uXCIsIGBCZWFyZXIgJHt0b2tlbn1gKTtcbiAgICAgIH1cbiAgICAgIGlmIChwcmVmZXJyZWRMb2NhbGUpIHtcbiAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoXCJBY2NlcHQtTGFuZ3VhZ2VcIiwgcHJlZmVycmVkTG9jYWxlKTtcbiAgICAgIH1cbiAgICAgIGlmICh4aHIudXBsb2FkICYmIG9uUHJvZ3Jlc3MpIHtcbiAgICAgICAgeGhyLnVwbG9hZC5vbnByb2dyZXNzID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgaWYgKGV2ZW50Lmxlbmd0aENvbXB1dGFibGUpIHtcbiAgICAgICAgICAgIG9uUHJvZ3Jlc3MoTWF0aC5yb3VuZCgoZXZlbnQubG9hZGVkIC8gZXZlbnQudG90YWwpICogMTAwKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgeGhyLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgaWYgKHhoci5zdGF0dXMgPT09IDQwMSAmJiAhZGlkUmV0cnkpIHtcbiAgICAgICAgICByZWZyZXNoVG9rZW4oKVxuICAgICAgICAgICAgLnRoZW4oKG5ld1Rva2VuKSA9PiB7XG4gICAgICAgICAgICAgIGlmIChuZXdUb2tlbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcGlVcGxvYWQ8VD4ocGF0aCwgZm9ybURhdGEsIG9uUHJvZ3Jlc3MsIHRydWUpLnRoZW4ocmVzb2x2ZSkuY2F0Y2gocmVqZWN0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZWplY3QobmV3IEFwaUVycm9yKFwiVW5hdXRob3JpemVkXCIsIDQwMSwgXCJVTkFVVEhPUklaRURcIikpO1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2gocmVqZWN0KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHhoci5zdGF0dXMgPj0gNDAwKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKHhoci5yZXNwb25zZVRleHQpIGFzIHsgbWVzc2FnZT86IHN0cmluZzsgY29kZT86IHN0cmluZzsgZGV0YWlscz86IHVua25vd24gfTtcbiAgICAgICAgICAgIHJlamVjdChuZXcgQXBpRXJyb3IoZGF0YS5tZXNzYWdlID8/IFwiUmVxdWVzdCBmYWlsZWRcIiwgeGhyLnN0YXR1cywgZGF0YS5jb2RlLCBkYXRhLmRldGFpbHMpKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBBcGlFcnJvcih4aHIucmVzcG9uc2VUZXh0IHx8IFwiUmVxdWVzdCBmYWlsZWRcIiwgeGhyLnN0YXR1cykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF4aHIucmVzcG9uc2VUZXh0KSB7XG4gICAgICAgICAgcmVzb2x2ZSh7fSBhcyBUKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmVzb2x2ZShKU09OLnBhcnNlKHhoci5yZXNwb25zZVRleHQpIGFzIFQpO1xuICAgICAgfTtcbiAgICAgIHhoci5vbmVycm9yID0gKCkgPT4ge1xuICAgICAgICByZWplY3QobmV3IEFwaUVycm9yKFwiTmV0d29yayBlcnJvclwiLCB4aHIuc3RhdHVzIHx8IDApKTtcbiAgICAgIH07XG4gICAgICB4aHIuc2VuZChmb3JtRGF0YSk7XG4gICAgfSk7XG5cbiAgcmV0dXJuIHVwbG9hZFdpdGhUb2tlbihhY2Nlc3NUb2tlbik7XG59XG4iXSwibmFtZXMiOlsidXNlQXV0aFN0b3JlIiwicHJvY2VzcyIsIkFQSV9VUkwiLCJlbnYiLCJORVhUX1BVQkxJQ19BUElfVVJMIiwiTE9DQUxFX1NUT1JBR0VfS0VZIiwiZ2V0UHJlZmVycmVkTG9jYWxlIiwic3RvcmVkIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsImNvb2tpZU1hdGNoIiwiZG9jdW1lbnQiLCJjb29raWUiLCJtYXRjaCIsImRlY29kZVVSSUNvbXBvbmVudCIsIkFwaUVycm9yIiwiRXJyb3IiLCJjb25zdHJ1Y3RvciIsIm1lc3NhZ2UiLCJzdGF0dXMiLCJjb2RlIiwiZGV0YWlscyIsInJlZnJlc2hUb2tlbiIsImdldFN0YXRlIiwicHJlZmVycmVkTG9jYWxlIiwicmVzcG9uc2UiLCJmZXRjaCIsIm1ldGhvZCIsImhlYWRlcnMiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsInJlZnJlc2hfdG9rZW4iLCJvayIsImNsZWFyVG9rZW5zIiwiZGF0YSIsImpzb24iLCJzZXRUb2tlbnMiLCJhY2Nlc3NfdG9rZW4iLCJhcGlGZXRjaCIsInBhdGgiLCJvcHRpb25zIiwiYWNjZXNzVG9rZW4iLCJIZWFkZXJzIiwiRm9ybURhdGEiLCJzZXQiLCJuZXdUb2tlbiIsInJldHJ5SGVhZGVycyIsInJldHJ5IiwidGV4dCIsImNvbnRlbnRUeXBlIiwiZ2V0IiwiaW5jbHVkZXMiLCJhcGlVcGxvYWQiLCJmb3JtRGF0YSIsIm9uUHJvZ3Jlc3MiLCJkaWRSZXRyeSIsInVwbG9hZFdpdGhUb2tlbiIsInRva2VuIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJ4aHIiLCJYTUxIdHRwUmVxdWVzdCIsIm9wZW4iLCJzZXRSZXF1ZXN0SGVhZGVyIiwidXBsb2FkIiwib25wcm9ncmVzcyIsImV2ZW50IiwibGVuZ3RoQ29tcHV0YWJsZSIsIk1hdGgiLCJyb3VuZCIsImxvYWRlZCIsInRvdGFsIiwib25sb2FkIiwidGhlbiIsImNhdGNoIiwicGFyc2UiLCJyZXNwb25zZVRleHQiLCJlcnJvciIsIm9uZXJyb3IiLCJzZW5kIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/api.ts\n"));

/***/ })

});